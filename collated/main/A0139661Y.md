# A0139661Y
###### /java/seedu/cmdo/commons/events/model/UndoActionEvent.java
``` java
/** Indicates the AddressBook in the model has changed*/
public class UndoActionEvent extends BaseEvent {

    public final ReadOnlyToDoList data;

    public UndoActionEvent(ReadOnlyToDoList data){
        this.data = data;
    }

    @Override
    public String toString() {
        return "number of tasks " 
        		+ data.getTaskList().size() 
        		+ ", number of tags " 
        		+ data.getTagList().size();
    }
}
```
###### /java/seedu/cmdo/commons/events/ui/StorageFileChangedEvent.java
``` java
/**
 * Indicates that the storage file has been modified by the user
 */
public class StorageFileChangedEvent extends BaseEvent {
	
	private String filePath;
	
	public StorageFileChangedEvent(String filePath) {
		this.filePath = filePath;
	}

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public String getFilePath() {
    	return filePath;
    }
}
```
###### /java/seedu/cmdo/commons/events/ui/UpDownCommandEvent.java
``` java
/**
 * Indicates an attempt to execute an incorrect command
 */
public class UpDownCommandEvent extends BaseEvent {
	private String type;

    public UpDownCommandEvent(String type) {
    	this.type = type;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### /java/seedu/cmdo/commons/exceptions/CannotUndoException.java
``` java
public class CannotUndoException extends Exception {
	public CannotUndoException(String message) {
		super(message);
	}
}
```
###### /java/seedu/cmdo/commons/exceptions/TaskBlockedException.java
``` java
/**
 * Signals that some given data does not fulfill some constraints.
 */
public class TaskBlockedException extends Exception {

    public TaskBlockedException(String message) {
        super(message);
    }
}
```
###### /java/seedu/cmdo/commons/util/SearchUtil.java
``` java
	// For searching of all parameters
    public static boolean containsIgnoreCase(String source, String query) {
        String[] split = source.toLowerCase().split("\\s+");
        List<String> strings = Arrays.asList(split);
        return strings.stream().filter(s -> s.equals(query.toLowerCase())
        		|| checkStringSimilarity(s, query) >= levenshtein_tolerance)
        		.count() > 0;
    }
    
```
###### /java/seedu/cmdo/commons/util/SearchUtil.java
``` java
    // For searching of tags.
    public static boolean containsIgnoreCase(UniqueTagList source, String query) {
    	ArrayList<String> strings = new ArrayList<String>(); 
    	for (Tag t : source) {
    		strings.add(t.tagName);
        }    	
        return strings.stream().filter(s -> s.equals(query.toLowerCase())
        		|| checkStringSimilarity(s, query) >= levenshtein_tolerance)
        		.count() > 0;
    }
    
```
###### /java/seedu/cmdo/commons/util/SearchUtil.java
``` java
    /**
     * Queries the task in question for date and time based on the user's NLP input.
     * 
     * @param dbd
     * @param dbt
     * @param query
     * @return boolean
     */
    public static boolean containsTimeAndDate(DueByDate dbd, DueByTime dbt, String query) {
    	Parser parser = new Parser();
    	List<DateGroup> dtl = parser.parse(query);
    	ArrayList<LocalDate> userDates = new ArrayList<LocalDate>();
    	ArrayList<LocalTime> userTimes = new ArrayList<LocalTime>();
    	for (DateGroup dg : dtl) {
    		List<Date> dl = dg.getDates();
    		for (Date d : dl) {
    			LocalDate ld = d.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    			LocalTime lt = d.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();
    			userDates.add(ld);
    			userTimes.add(lt);
    		}
    	}
    	// User time will never be empty so there is no time
    	if (userTimes.isEmpty()) return false;
    	ArrayList<LocalDate> dates = new ArrayList<LocalDate>();
    	ArrayList<LocalTime> times = new ArrayList<LocalTime>(); 
    	if (dbt.isRange()) {
    		times.add(dbt.end);
    	} if (!dbt.isFloating()) {
    		times.add(dbt.start);
    	} if (dbd.isRange()) {
    		dates.add(dbd.end);
    	} if (!dbd.isFloating()) {
    		dates.add(dbd.start);
    	}
    	if (dates.contains(LocalDate.now())) {
    		return times.stream().filter(s -> userTimes.contains(s)).count() > 0;
    	}
    	return times.stream().filter(s -> userTimes.contains(s)).count() > 0 
    			|| dates.stream().filter(s -> userDates.contains(s)).count() > 0; 
    }
}
```
###### /java/seedu/cmdo/logic/commands/AddCommand.java
``` java
    /**
     * Created an add command for SINGULAR NON-RANGE DATE AND TIME
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String details,
                      LocalDate dueByDate,
                      LocalTime dueByTime,
                      String priority,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Detail(details),
                new DueByDate (dueByDate),
                new DueByTime(dueByTime),
                new Priority(priority),
                new UniqueTagList(tagSet)
        );
        isUndoable = true;
    }
    
```
###### /java/seedu/cmdo/logic/commands/AddCommand.java
``` java
    /**
     * Created an add command for RANGE DATE AND TIME
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String details,
                      LocalDate dueByDateStart,
                      LocalTime dueByTimeStart,
                      LocalDate dueByDateEnd,
                      LocalTime dueByTimeEnd,
                      String priority,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Detail(details),
                new DueByDate (dueByDateStart, dueByDateEnd),
                new DueByTime(dueByTimeStart, dueByTimeEnd),
                new Priority(priority),
                new UniqueTagList(tagSet)
        );
        isUndoable = true;
    }


    public AddCommand(Task toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyTask getTask() {
        return toAdd;
    }

```
###### /java/seedu/cmdo/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() {
    	try {
    		// Check for block conflicts. Throws a TaskBlockedException if conflicts exist.
    		blocker.checkBlocked(toAdd, model.getBlockedList());
        	updateSelectionInPanel(model.addTask(toAdd));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (TaskBlockedException tbe) {
    		return new CommandResult(tbe.getMessage());
        }
    }
}
```
###### /java/seedu/cmdo/logic/commands/Command.java
``` java
    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of done tasks only.
     *
     * @param displaySize used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForDoneTaskListShownSummary(int displaySize) {
        return String.format(Messages.MESSAGE_DONE_TASKS_LISTED_OVERVIEW, displaySize);
    }
    
    /**
     * Constructs a feedback message to summarise an operation that displayed finding of tasks.
     *
     * @param keywords Set of keywords input by the user
     * @return summary message for tasks displayed
     */
    public static String getMessageForFindSummary(Set<String> keywords) {
        return String.format(Messages.MESSAGE_TASKS_FOUND_OVERVIEW, keywords.toString(), SearchUtil.levenshtein_tolerance);
    }

    /**
     * Executes the command and returns the result message.
     *
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult execute();

    /**
     * Provides any needed dependencies to the command.
     * Commands making use of any of these should override this method to gain
     * access to the dependencies.
     */
    public void setData(Model model) {
        this.model = model;
    }
    
```
###### /java/seedu/cmdo/logic/commands/Command.java
``` java
    public void setCurrentSelected(int index) {
    	this.currentSelected = index;
    }
    
    /**
     * Raises an event to indicate an attempt to execute an incorrect command
     */
    protected void indicateAttemptToExecuteIncorrectCommand() {
        EventsCenter.getInstance().post(new IncorrectCommandAttemptedEvent(this));
    }
    
```
###### /java/seedu/cmdo/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all tasks in CMDo whose name contains any of the argument keywords.
 * Keyword matching is case insensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-insensitive)," + "\n" + "/priorities and/or completion status, displaying them as a list with index numbers.\n"
            + "Parameters: <keyword> <more keywords>\n"
            + "Example: " + COMMAND_WORD + " dog";

    private final Set<String> keywords;
    private final boolean taskStatus;

    public FindCommand(Set<String> keywords, boolean taskStatus) {
        this.keywords = keywords;
        this.taskStatus = taskStatus;
    }

    @Override
    public CommandResult execute() {
    	model.updateFilteredTaskList(keywords, taskStatus);
        return new CommandResult(getMessageForFindSummary(keywords));
        
    }
}
```
###### /java/seedu/cmdo/logic/commands/ListCommand.java
``` java
/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_WORD_SHORT_ALL = "la";
    public static final String COMMAND_WORD_SHORT_DONE = "ld";
    public static final String COMMAND_WORD_SHORT_BLOCK = "lb";
    public static final String COMMAND_WORD_ALL = "list all";
    public static final String COMMAND_WORD_DONE = "list done";
    public static final String COMMAND_WORD_BLOCK = "list block";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";
    public static final String MESSAGE_USAGE = COMMAND_WORD + "/" + COMMAND_WORD_SHORT_ALL + "/" 
    		+ COMMAND_WORD_SHORT_DONE + "/" + COMMAND_WORD_SHORT_BLOCK + "/" + COMMAND_WORD_ALL + "/" 
    		+ COMMAND_WORD_DONE + "/" + COMMAND_WORD_BLOCK + ": lists wanted list\n" 
    		+ "Example: list all";
    
    private final int type; // 0 for done false, 1 for done true, 2 for blocked and done false

    public ListCommand(int type) {
    	this.type = type;
    }

    @Override
    public CommandResult execute() {
    	if (type == 0)
    		model.updateFilteredListToShowAll(false);
    	else if (type == 1) {
        	model.updateFilteredListToShowAll(true);
    		return new CommandResult(getMessageForDoneTaskListShownSummary(model.getFilteredTaskList().size()));
        } else if (type == 2)
        	model.updateFilteredListToShowBlocked();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### /java/seedu/cmdo/logic/commands/UndoCommand.java
``` java
/**
 * Represents an undo command.
 */
public class UndoCommand extends Command {
	
	public static final String COMMAND_WORD = "undo";
	
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "undos previous action\n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_UNDO_SUCCESS = "Undone!";
	
	public UndoCommand() {}

	@Override
	public CommandResult execute() {
		try {
			model.undo();
		} catch (CannotUndoException cue) {
			return new CommandResult(cue.getMessage());
		}
    	 
		return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS));
	}
}
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override	
    public CommandResult execute(String commandText) {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        // Get snapshot of existing todolist. We store a new object, not a reference.
        if (command.isUndoable) {
        	undoer.snapshot(new ToDoList(model.getToDoList()));
        	logger.info("Snapshot taken of " + model.getToDoList().toString());
        }
        // Pop redo stack unless command is undo
        if (!command.getClass().equals(UndoCommand.class) && 
        		!command.getClass().equals(RedoCommand.class)) {
        	undoer.clearRedoStack();
        	logger.info("Redo stack cleared.");
        }
        command.setData(model);
        command.setCurrentSelected(currentSelected);
        return command.execute();
    }
    
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getBlockedList() {
    	return model.getBlockedList();
    }
    
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getAllTaskList() {
    	return model.getAllTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
    
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList(boolean firstRun) {
        return model.getFilteredTaskList(firstRun);
    }    
    
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    @Subscribe
    public void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, 
        		String.format("Current selection is index %d", event.targetIndex)));
        currentSelected = event.targetIndex;
    }
}
```
###### /java/seedu/cmdo/logic/parser/Blocker.java
``` java
public class Blocker {

    private static final Logger logger = LogsCenter.getLogger(MainApp.class);
	
	LocalDate checkingDate;
	LocalTime checkingTime;
	LocalDateTime checking;
	LocalDateTime againstStart;
	LocalDateTime againstEnd;

	public Blocker() {}

	public ArrayList<LocalDateTime> checkBlocked(Task toCheck, UnmodifiableObservableList<ReadOnlyTask> blockedList)
										throws TaskBlockedException {
		ArrayList<LocalDateTime> dateTimeList = new ArrayList<LocalDateTime>();
		if (toCheck.isRange()) {
			LocalDateTime startDt = LocalDateTime.of(toCheck.getDueByDate().start, toCheck.getDueByTime().start);
			LocalDateTime endDt = LocalDateTime.of(toCheck.getDueByDate().end, toCheck.getDueByTime().end);
			dateTimeList.add(startDt);
			dateTimeList.add(endDt);
		} else {
    		LocalDateTime dt = LocalDateTime.of(toCheck.getDueByDate().start, toCheck.getDueByTime().start);
    		dateTimeList.add(dt);
		}
        if (isBlocked(dateTimeList, blockedList)) {
        	throw new TaskBlockedException(Messages.MESSAGE_TIMESLOT_BLOCKED);
        }
        return dateTimeList;
	}
	
	/**
	 * Checks to see if a local date time array list of ranges falls within a blocked slot.
	 * 
	 * @param datesAndTimes
	 * @return boolean based on outcome
	 */
	public boolean isBlocked(List<LocalDateTime> datesAndTimes, UnmodifiableObservableList<ReadOnlyTask> blockedList) {
		reset();
		for (LocalDateTime dt : datesAndTimes) {
			logger.info(String.format("Checking before is %s", checking.toString()));
			checkingDate = dt.toLocalDate();
			checkingTime = dt.toLocalTime();
			checking = LocalDateTime.of(checkingDate, checkingTime);
			logger.info(String.format("Checking after is %s", checking.toString()));
			for (ReadOnlyTask rot : blockedList) {
				againstStart = LocalDateTime.of(rot.getDueByDate().start, rot.getDueByTime().start);
				againstEnd = LocalDateTime.of(rot.getDueByDate().end, rot.getDueByTime().end);
				logger.info(String.format("AgainstStart is %s", againstStart.toString()));
				logger.info(String.format("AgainstEnd is %s", againstEnd.toString()));
				if ((checking.isAfter(againstStart) && checking.isBefore(againstEnd))
						|| checking.isEqual(againstStart) 
						|| checking.isEqual(againstEnd)) {
					logger.info("Date is between blocked range.");
					return true; 
				}
			}
		}
		return false;
	}
	
	/**
	 * Resets values such that each time the Blocker is called we start fresh
	 */
	private void reset() {
		checkingDate = LocalDate.MAX;
		checkingTime = LocalTime.MAX;
		checking = LocalDateTime.MAX;
		againstStart = LocalDateTime.MIN;
		againstEnd = LocalDateTime.MIN;
	}
}
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Initialize main parser.
     */
    private void init() {
    	datesAndTimes = new ArrayList<LocalDateTime>();
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
    	reset();
    	String[] splitedInput = userInput.split("\\s+");
    	String commandWord, arguments; 
    	if(splitedInput.length == 2 && 
    			((splitedInput[1].equals("done")) || (splitedInput[1].equals("all")) || splitedInput[1].equals("block"))) {
    		Matcher matcher = LIST_COMMAND_FORMAT.matcher(userInput.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }
            commandWord = matcher.group("commandWord");
            arguments = matcher.group("arguments");
    	}
    	else{
    		Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }
            commandWord = matcher.group("commandWord");
            arguments = matcher.group("arguments");
            
    	}
    	args = getCleanString(arguments);
        args = convertToTo(args); 
        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd();
       
        case BlockCommand.COMMAND_WORD:
            return prepareBlock();

        case SelectCommand.COMMAND_WORD:
            return prepareSelect();

        case StorageCommand.COMMAND_WORD:
        	return prepareStorage();
            
        case DeleteCommand.COMMAND_WORD:
            return prepareDelete();
            
        case DoneCommand.COMMAND_WORD:
            return prepareDone();

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();
            
        case RedoCommand.COMMAND_WORD:
            return new RedoCommand();
            
        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();
            
        case EditCommand.COMMAND_WORD:
        	return prepareEdit();

        case FindCommand.COMMAND_WORD:
            return prepareFind();
            
        case ListCommand.COMMAND_WORD_DONE:	
        case ListCommand.COMMAND_WORD_SHORT_DONE:
            return prepareList("--done");
        case ListCommand.COMMAND_WORD_BLOCK:
        case ListCommand.COMMAND_WORD_SHORT_BLOCK:
        	return prepareList("--block");
        case ListCommand.COMMAND_WORD:
        case ListCommand.COMMAND_WORD_ALL:        	
        case ListCommand.COMMAND_WORD_SHORT_ALL:
        	return prepareList(args);
        	
        case UpDownCommand.UP:
        case UpDownCommand.UP_ALT:
        	return new UpDownCommand(UpDownCommand.UP);
        case UpDownCommand.DOWN:
        case UpDownCommand.DOWN_ALT:
        	return new UpDownCommand(UpDownCommand.DOWN);
        case UpDownCommand.TOP:
        case UpDownCommand.TOP_ALT:
        	return new UpDownCommand(UpDownCommand.TOP);
        case UpDownCommand.BOTTOM:
        case UpDownCommand.BOTTOM_ALT:
        	return new UpDownCommand(UpDownCommand.BOTTOM);
        	
        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
    
    /** PREPARATION METHODS **/
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    private Command prepareAdd(){
    	datesAndTimes.clear();
    	try {
        	process();
    		if (dateTimeType <= 1) {
    			return new AddCommand(
    					detailToAdd,
    					dt.toLocalDate(),
    					dt.toLocalTime(),
    					extractPriority(),
    					getTagsFromArgs());
    		} else {
    			return new AddCommand(
    					detailToAdd,
    					dtStart.toLocalDate(),
    					dtStart.toLocalTime(),
    					dtEnd.toLocalDate(),
    					dtEnd.toLocalTime(),
    					extractPriority(),
    					getTagsFromArgs());
    		}
    	} catch (IllegalValueException ive) {
    		return new IncorrectCommand(ive.getMessage());
    	}
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    private Command prepareList(String args) {
        int type = 0; // we assume the user is searching for undone tasks
        if (args.contains("--done")) {
        	type = 1;
        } else if (args.contains("--block")) {
        	type = 2;
        }
        return new ListCommand(type);
    }
    
//  ============== HELPER METHODS
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Processes parameters detail, dbt, dbd, priority.
     * 
     * @throws IllegalValueException if any are invalid.
     */
    private void process() throws IllegalValueException {
    	extractDetail();			// Saves to detailToAdd
    	extractDueByDateAndTime(); 	// Saves to datesAndTimes
    	checkPriorityValidity(); 	// Throws exception if priority entered wrongly
    	splittedArgs = getCleanString(args).split(" ");
    	saveDueByDateAndTime(); 	// Saves to dt family.
    	reset();         			// Clear dates and times		
	}

```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Extracts the priority out of the args.
     * If / precedes neither high, medium or low, it will throw an error
     * Otherwise, it is taken to have default no priority.
     * 
     * @param splittedArgs an array of split user input
     * @return priority level string.
     */ 
    private String extractPriority() throws IllegalValueException {
    	List<String> rawArgs = Arrays.asList(splittedArgs);
    	for (String rawArg : rawArgs) {
    		if (rawArg.toLowerCase().startsWith("/")) {
    			switch(rawArg.replace("/", "")) {
    			case Priority.HIGH:
    				return Priority.HIGH;
    			case Priority.MEDIUM:
    				return Priority.MEDIUM;
    			case Priority.LOW:
    				return Priority.LOW;
    			default:
    				throw new IllegalValueException(MESSAGE_INVALID_PRIORITY);
    			}
    		}
    	}
    	return "";
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /** 
     * Takes out the date and time of the natural language input
     */
    public void extractDueByDateAndTime() {
    	List<DateGroup> groups = parser.parse(args);
    	String cleanArgs = args;
    	
    	try {
    		// This retrieves either the start date/time, or the only date/time.
    		for (int i=0; i<groups.size(); i++) {
	    		DateGroup group = groups.get(i);
	    		List<Date> dateList = group.getDates(); 	// Extract date
	    		Map<String, List<ParseLocation>> parseMap = group.getParseLocations();
	    		if ((!parseMap.containsKey("explicit_time") && parseMap.containsKey("relative_date")) || 
	    				(!parseMap.containsKey("explicit_time") && parseMap.containsKey("formal_date"))) {
	    			for (Date date : dateList) {
	    				LocalDateTime temp = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
	    				datesAndTimes.add(LocalDateTime.of(temp.toLocalDate(), LocalTime.MAX));
	    			}
	    		} else {
	    			for (Date date : dateList) {
	    				datesAndTimes.add(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()));
	    			}
	    		}
	    		for (ParseLocation parsedWord : parseMap.get("parse")) {
	    			cleanArgs = cleanArgs.substring(0, parsedWord.getStart() - 1) + cleanArgs.substring(parsedWord.getEnd() -1);
	    		}
    		}
    		// Sort dates and times according to whichever is earlier
    		Collections.sort(datesAndTimes);
    		args = cleanArgs;	// Return a cleaned up string
    	} catch (IndexOutOfBoundsException e) {} // No date/time found. Do nothing
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Checks if the detail input is valid, as in, it requires the use of encapsulating ' ',
     * and must not be blank. This is used in conjunction with {@link #extractDetail()}.
     * 
     * @throws IllegalValueException if only one ' found, or if detail is blank.
     */
	private void checkValidDetailInput() throws IllegalValueException {
    	// Check if only one ' used
    	if (args.lastIndexOf("'") == args.indexOf("'"))
    		throw new IllegalValueException(MESSAGE_ENCAPSULATE_DETAIL_WARNING);
    	// Check if detail is empty.
    	if (args.lastIndexOf("'") == args.indexOf("'")+1)
    		throw new IllegalValueException(MESSAGE_BLANK_DETAIL_WARNING);
	}
	
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
	/**
     * Checks if the detail input is valid, as in, it must not be blank. 
     * This is used in conjunction with {@link #extractDetailForEdit()}.
     * 
     * @throws IllegalValueException if only one ' found, or if detail is blank.
     */
	private boolean checkValidDetailInputForEdit() throws IllegalValueException {
    	// Check if only one ' used
    	if (args.lastIndexOf("'") == args.indexOf("'"))
    		return false;
    	// Check if detail is empty.
    	if (args.lastIndexOf("'") == args.indexOf("'")+1)
    		throw new IllegalValueException(MESSAGE_BLANK_DETAIL_WARNING);
    	return true;
	}

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     * 
     * @throws IllegalValueException if tag input is invalid.
     */
    private static Set<String> getTagsFromArgs() throws IllegalValueException {
    	List<String> rawArgs = Arrays.asList(splittedArgs);
    	Collection<String> tagStrings = new ArrayList<String>();
    	boolean isEmpty = true;
    	for (String rawArg : rawArgs) {
    		isEmpty = false;
    		if (rawArg.startsWith("-")) {
    			tagStrings.add(rawArg.replace("-", ""));
    		}
    	}
    	if (isEmpty) {
    		return Collections.emptySet();
    	} 
    	return new HashSet<>(tagStrings);
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Utility method which replaces all redundant spaces
     * 
     * @param args an uncleaan string
     * @return a cleaned up string
     */
    private String getCleanString(String args) {
    	return args.trim().replaceAll("\\s+", " ");
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     * An index is loose if there are arguments after the index.  
     *   
     * @return {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseLooseIndex(String command) {
        final Matcher matcher = TASK_LOOSE_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));
    } 

```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
	 * Checks for accidental '/' instead of ' /'.
	 * 
	 * @throws IllegalValueException
	 */
    private void checkPriorityValidity() throws IllegalValueException {
    	if (args.contains("/") && !args.contains(" /"))
    		throw new IllegalValueException(Messages.MESSAGE_INVALID_PRIORITY_SPACE);
	}

```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Checks if the user wants to edit time or priority.
     * Used in conjunction with {@link #prepareEdit()}
     */
    private void checkSpecialRequestInEdit() {
        //if keyword float is entered, it becomes a floating task (no date no time)
        if(args.toLowerCase().contains("floating") || args.toLowerCase().contains("fl")){
        	floatingRequestInEdit = true;
        }
        //if keyword is only, we take it that the user means to have a single time or date.
        else if (args.toLowerCase().contains("only")) {
        	onlyOneDateOrTimeRequestInEdit = true;
        }
        //if keyword rp or remove priority is entered, priority is removed
        if(args.toLowerCase().contains("no priority") || args.toLowerCase().contains("np")) {
        	priorityRequestInEdit = true;
        }
        
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Tests to see if command ends in an index.
     * 
     * @return boolean indicative of where index is present
     */
    private boolean isIndexInCommandPresent() {
    	Optional<Integer> checkForIndex = parseIndex(args);
    	if (!checkForIndex.isPresent()) 
    		return false;
    	targetIndex = checkForIndex.get();
    	return true;
    }

```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Tests to see if command ends in a loose index.
     * A loose index is an index with proceeding strings.
     * 
     * @return boolean indicative of where loose index is present
     */    
    private boolean isLooseIndexInCommandPresent() {
    	Optional<Integer> checkForIndex = parseLooseIndex(args);
    	if (!checkForIndex.isPresent()) 
    		return false;
    	targetIndex = checkForIndex.get();
    	return true;
    }
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
	 * Saves the date and time from list to dt family according to the following table
	 * 
	 * ______________________
	 * | type 	| condition	|
	 * ----------------------
	 * | 0		| no DT		|
	 * | 1		| single DT	|
	 * | 2		| two DT	|
	 * ======================
	 */
    private void saveDueByDateAndTime() {
    	if (datesAndTimes.size() == 1) {
    		dt = datesAndTimes.get(0);
    		dateTimeType = 1;
    	} else if (datesAndTimes.size() == 2) {
    		dtStart = datesAndTimes.get(0);
    		dtEnd = datesAndTimes.get(1);
    		dateTimeType = 2;
    	} else {
    		dt = LocalDateTime.of(NO_DATE_DEFAULT, NO_TIME_DEFAULT);
    		dateTimeType = 0;
    	}
	}
    
    
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
    /**
     * Overrides the DBD and DBT when editing or adding a block task.
     * This is to comply with the constraints specified for blocks.
     * 
     * @throws IllegalValueException
     */
    private void overrideDueByDateAndTimeForBlock() throws IllegalValueException {
		// Override saveDueByDateAndTime()
    	if (dateTimeType == 0) {
    		throw new IllegalValueException("Specify a time/date range for the block.");
    	}
    	// Only one time or date or both
    	if (dateTimeType == 1) {
    		// Case 1: Date only
    		if (dt.toLocalTime().equals(NO_TIME_DEFAULT)) {
    			dtStart = dt;
    			dtEnd = dt;
    		} else {
        		// Case 2: Time only or date and time only
    			dtStart = dt;
    			dtEnd = dt.plusHours(1);
    		}
			dt = NO_DATETIME_DEFAULT;
    	}
    }

```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
	private void reset() {
        datesAndTimes.clear();
        args = EMPTY_STRING;
        floatingRequestInEdit = false;
        priorityRequestInEdit = false;
	}

}
```
###### /java/seedu/cmdo/MainApp.java
``` java
	/** 
     * Read user defined settings, if any 
     * @throws Exception
     */
	private void syncUserPrefsToConfig() throws Exception {
        config.setToDoListFilePath(userPrefs.getStorageSettings().getFilePath());
        storage.updateFilePathInUserPrefs(config.getToDoListFilePath());
        storage.saveToDoList(model.getToDoList());
	}

    private String getApplicationParameter(String parameterName){
        Map<String, String> applicationParameters = getParameters().getNamed();
        return applicationParameters.get(parameterName);
    }

    private Model initModelManager(Storage storage, UserPrefs userPrefs) {
        Optional<ReadOnlyToDoList> toDoListOptional;
        ReadOnlyToDoList initialData;
        try {
            toDoListOptional = storage.readToDoList();
            if(!toDoListOptional.isPresent()){
                logger.info("Data file not found. Will be starting with an empty ToDoList");
            }
            initialData = toDoListOptional.orElse(new ToDoList());
        } catch (DataConversionException e) {
            logger.warning("Data file not in the correct format. Will be starting with an empty ToDoList");
            initialData = new ToDoList();
        } catch (FileNotFoundException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty ToDoList");
            initialData = new ToDoList();
        } catch(Exception e) {
        	logger.warning("Data file not found. Will be starting with an empty ToDoList");
        	initialData = new ToDoList();
        }

        return new ModelManager(initialData, userPrefs);
    }

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    protected Config initConfig(String configFilePath) {
        Config initializedConfig;
        String configFilePathUsed;

        configFilePathUsed = Config.DEFAULT_CONFIG_FILE;

        if(configFilePath != null) {
            logger.info("Custom Config file specified " + configFilePath);
            configFilePathUsed = configFilePath;
        }

        logger.info("Using config file : " + configFilePathUsed);

        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(configFilePathUsed);
            initializedConfig = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            logger.warning("Config file at " + configFilePathUsed + " is not in the correct format. " +
                    "Using default config properties");
            initializedConfig = new Config();
        }

        //Update config file in case it was missing to begin with or there are new/unused fields
        try {
            ConfigUtil.saveConfig(initializedConfig, configFilePathUsed);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
        return initializedConfig;
    }

    protected UserPrefs initPrefs(Config config) {
        assert config != null;

        String prefsFilePath = config.getUserPrefsFilePath();
        logger.info("Using prefs file : " + prefsFilePath);

        UserPrefs initializedPrefs;
        try {
            Optional<UserPrefs> prefsOptional = storage.readUserPrefs();
            initializedPrefs = prefsOptional.orElse(new UserPrefs());
        } catch (DataConversionException e) {
            logger.warning("UserPrefs file at " + prefsFilePath + " is not in the correct format. " +
                    "Using default user prefs");
            initializedPrefs = new UserPrefs();
        } catch (IOException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty ToDoList");
            initializedPrefs = new UserPrefs();
        }

        // Update prefs file in case it was missing to begin with or there are new/unused fields
        try {
            storage.saveUserPrefs(initializedPrefs);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }

        return initializedPrefs;
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting ToDoList " + MainApp.VERSION);
        ui.start(primaryStage);
    }

    @Override
    public void stop() {
        logger.info("============================ [ Stopping CMDo ] =============================");
        ui.stop();
        try {
            storage.saveUserPrefs(userPrefs);
        } catch (IOException e) {
            logger.severe("Failed to save preferences " + StringUtil.getDetails(e));
        }
        Platform.exit();
        System.exit(0);
    }
    
    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }
    
```
###### /java/seedu/cmdo/MainApp.java
``` java
    /**
     * Handles an event where the storage file has been changed.
     * @param event
     */
    @Subscribe
    public void handleStorageFileChangedEvent(StorageFileChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        try {
        	syncUserPrefsToConfig();
        } catch (Exception e) {
        	logger.severe("Failed to update config file.");
        }
    }

    public static void main(String[] args) {
        launch(args);
    }

}
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given ToDoList
     * ToDoList and its variables should not be null
     */
    public ModelManager(ToDoList src, UserPrefs userPrefs) {
        super();
        assert src != null;
        assert userPrefs != null;

        logger.fine("Initializing with todo list: " + src + " and user prefs " + userPrefs);

        toDoList = new ToDoList(src);
        filteredTasks = new FilteredList<>(toDoList.getTasks());
        this.userPrefs = userPrefs;
        this.undoer = Undoer.getInstance();
        logger.info("Saved new toDoList into Undoer stack. " + toDoList.toString());
    }

    public ModelManager() {
        this(new ToDoList(), new UserPrefs());
    }

```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    public ModelManager(ReadOnlyToDoList initialData, UserPrefs userPrefs) {
        toDoList = new ToDoList(initialData);
        filteredTasks = new FilteredList<>(toDoList.getTasks());
        this.userPrefs = userPrefs;
        this.undoer = Undoer.getInstance();
        logger.info("Saved last stable toDoList into Undoer stack. " + toDoList.toString());
    }

    @Override
    public void resetData(ReadOnlyToDoList newData) {
    	toDoList.resetData(newData);
        indicateToDoListChanged();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
    	return toDoList;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(toDoList));
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public synchronized void undo() throws CannotUndoException {
    	try {
    		ToDoList currentState = new ToDoList(toDoList);
    		toDoList.resetData(undoer.undo(currentState));
    		logger.info("Undo operation called.");
    	} catch (EmptyStackException ese) {
    		throw new CannotUndoException("Nothing to undo.");
    	}
    	indicateToDoListChanged();
    	updateFilteredListToShowAll();
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public synchronized void doneTask(ReadOnlyTask target, Task replacer) throws TaskNotFoundException, TaskAlreadyDoneException {
        toDoList.removeTask(target);
    	toDoList.addTask(replacer);
        indicateToDoListChanged();
    	updateFilteredListToShowAll();
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public synchronized int addTask(Task task) {
        toDoList.addTask(task);
        updateFilteredListToShowAll();
        indicateToDoListChanged();
        return findTaskInModel(task);
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public synchronized int editTask(ReadOnlyTask taskToEdit, Task toEditWith) throws TaskNotFoundException {
    	toDoList.editTask(taskToEdit, toEditWith);
    	updateFilteredListToShowAll();
    	indicateToDoListChanged();
        return findTaskInModel(toEditWith);
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public void changeStorageFilePath(String filePath) {
    	userPrefs.setStorageSettings(filePath);
    	indicateToDoListChanged();
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getAllTaskList() {
    	return new UnmodifiableObservableList<>(toDoList.getTasks());
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
    	return new UnmodifiableObservableList<>(filteredTasks); 
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(boolean firstRun) {
    	UnmodifiableObservableList<ReadOnlyTask> initList = new UnmodifiableObservableList<>(filteredTasks);
    	// This prevents even done tasks from showing up at first run.
    	updateFilteredListToShowAll(false);
    	return initList;
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getBlockedList() {
    	UnmodifiableObservableList<ReadOnlyTask> initList = new UnmodifiableObservableList<>(filteredTasks);
    	updateFilteredListToShowBlocked();
    	return initList;
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowBlocked() {
        updateFilteredListToShowAll(new PredicateExpression(new BlockQualifier()));
    }
    
    // By default a list with no done tasks where taskStatus is false
    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredListToShowAll(new PredicateExpression(new DetailQualifier()));
    }
    
    // Used by find done or list done where taskStatus is true
    @Override
    public void updateFilteredListToShowAll(boolean taskStatus) {
        updateFilteredListToShowAll(new PredicateExpression(new DetailQualifier(taskStatus)));
    }
    
    private void updateFilteredListToShowAll(Expression expression) {
    	assert expression != null;
    	filteredTasks.setPredicate(expression::satisfies);
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    // Used by find done <...> or find <...> where taskStatus depends on user input.
    @Override
    public void updateFilteredTaskList(Set<String> keywords, boolean taskStatus){
        updateFilteredTaskList(new PredicateExpression(new DetailQualifier(keywords, taskStatus)));
    }

    private void updateFilteredTaskList(Expression expression) {
    	filteredTasks.setPredicate(expression::satisfies);
    }
    
    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class DetailQualifier implements Qualifier {
        private Set<String> detailKeyWords = Collections.EMPTY_SET;
        private final boolean taskStatus;
        
        // Keywords, specified tasks status
        // Likely a find done <...> or find <...>
        DetailQualifier(Set<String> detailKeyWords, boolean taskStatus) {
            this.detailKeyWords = detailKeyWords;
            this.taskStatus = taskStatus;
        }
        
        // No keywords, a specified task status
        // Likely a find done or a list done
        DetailQualifier(boolean taskStatus) {
            this.taskStatus = taskStatus;
        }
        
        // No keywords, no specified task status
        // Likely a list
        DetailQualifier() {
        	taskStatus = false;
        }
        
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
        /*
         * Matches tasks with command done parameter, and filters.
         * 
         * @return boolean: true if match, false if not
         */
        @Override
        public boolean run(ReadOnlyTask task) {
        	// Determine if done tasks match the user's filter criteria.
        	// In this case, no keywords were specified.
        	if (detailKeyWords.isEmpty()) {
        		return task.checkDone().value.equals(taskStatus);
        	}
        	if (task.checkDone().value != taskStatus)
        		return false;
            return detailKeyWords.stream()
                    .filter(keyword -> (SearchUtil.containsIgnoreCase(task.getDetail().details, keyword)
                    					|| SearchUtil.containsIgnoreCase(task.getPriority().value, keyword)
                    					|| SearchUtil.containsIgnoreCase(task.getTags(), keyword)
                    					|| SearchUtil.containsTimeAndDate(task.getDueByDate(), task.getDueByTime(), keyword)))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "detail=" + String.join(", ", detailKeyWords);
        }
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    private class BlockQualifier implements Qualifier {           
        /*
		 * Produces a list of blocks only.
         * 
         * @return boolean: true if match, false if not
         */
        @Override
        public boolean run(ReadOnlyTask task) {
        	return task.getBlock();
        }
    }
}
```
###### /java/seedu/cmdo/model/task/Detail.java
``` java
/**
 * Represents a Task's detail in the To Do List.
 * Guarantees: immutable; is valid as declared in {@link #isValidDetail(String)}
 */
public class Detail {

    public static final String MESSAGE_DETAIL_CONSTRAINTS = "You can type anything in details. It must not end with by, on, before or at.";
    public static final String DETAIL_VALIDATION_REGEX = ".*";

    public final String details;

    /**
     * Validates given detail.
     *
     * @throws IllegalValueException if given detail string is invalid.
     */
    public Detail(String detail) throws IllegalValueException {
        assert detail != null;
        detail = detail.trim();
        if (!isValidDetail(detail)) {
            throw new IllegalValueException(MESSAGE_DETAIL_CONSTRAINTS);
        }
        this.details = detail;
    }

    /**
     * Returns true if a given string is a valid detail.
     */
    public static boolean isValidDetail(String test) {
        return test.matches(DETAIL_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return details;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Detail // instanceof handles nulls
                && this.details.equals(((Detail) other).details)); // state check
    }

    @Override
    public int hashCode() {
        return details.hashCode();
    }

}
```
###### /java/seedu/cmdo/model/task/ReadOnlyTask.java
``` java
/**
 * A read-only immutable interface for a task in the To Do List.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask extends Cloneable {
	
    Detail getDetail();
    Done checkDone();
    DueByDate getDueByDate();
    DueByTime getDueByTime();
    Priority getPriority();
	boolean getBlock();
	boolean isRange();
	LocalDateTime getStartLdt();

    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
           
                && other.getDetail().details.equals(this.getDetail().details) // state checks here onwards
                && other.checkDone().value.equals(this.checkDone().value)
                && other.getDueByDate().toString().equals(this.getDueByDate().toString())
                && other.getDueByTime().toString().equals(this.getDueByTime().toString())
                && other.getPriority().value.equals(this.getPriority().value)
                && other.getBlock() == (this.getBlock()));
    }

  /**
   * Formats the task as text, showing all details.
   */
  default String getAsText() {
	    return getDetail().details;
  }

    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }
}
```
###### /java/seedu/cmdo/model/task/Task.java
``` java
    /**
     * Copy constructor with dereferencing Done value. This ensures that source's value does not get modified along with the new task's.
     */
    public Task(ReadOnlyTask source, Done done) {
        this(source.getDetail(), done, source.getDueByDate(), source.getDueByTime(), source.getPriority(), source.getBlock(), source.getTags());
    }
    
```
###### /java/seedu/cmdo/model/task/Task.java
``` java
    /**
     * Returns a proper parser understandable date string for testing purposes.
     * @return friendly string of date object.
     */
    public String getFriendlyDate() {
    	return dueByDate.getFriendlyString();  
    }
    
```
###### /java/seedu/cmdo/model/task/Task.java
``` java
    /**
     * Returns a proper parser understandable date string for testing purposes.
     * @return friendly string of time object.
     */
    public String getFriendlyTime() {
    	return dueByTime.getFriendlyString();
    }
    
```
###### /java/seedu/cmdo/model/task/Task.java
``` java
	@Override
	public int compareTo(Object o) {
		int i = this.getStartLdt().compareTo(((Task) o).getStartLdt());
    	if (i != 0) return i;
    	return this.getDetail().toString().compareToIgnoreCase(((Task)o).getDetail().toString());
	}
}
```
###### /java/seedu/cmdo/model/task/UniqueTaskList.java
``` java
    /**
     * Signals that the task is already done and cannot be done again.
     */
    public static class TaskAlreadyDoneException extends Exception {}

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty TaskList.
     */
    public UniqueTaskList() {}

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) {
        assert toAdd != null;
        internalList.add(toAdd);
    }

```
###### /java/seedu/cmdo/model/task/UniqueTaskList.java
``` java
    /**
     * Retrieves the equivalent task in the list for editing.
     *
     * @throws TaskNotFoundException
     */
    public void edit(ReadOnlyTask toEdit, Task toEditWith) throws TaskNotFoundException {
    	assert (toEdit != null && toEditWith != null);
    	int index = internalList.indexOf(toEdit);
    	if (index == -1) {
    		throw new TaskNotFoundException();
    	}
    	internalList.set(index, toEditWith);
    }
    
    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### /java/seedu/cmdo/model/Undoer.java
``` java
public class Undoer {
	private static Undoer undoer;
	private Stack<ReadOnlyToDoList> undoList;
	private Stack<ReadOnlyToDoList> redoList;
	private EventsCenter ec;

    private Undoer(ReadOnlyToDoList initialTdl) {
		init(initialTdl);
    }
    
    public static Undoer getInstance(ReadOnlyToDoList initialTdl) {
    	if (undoer == null) {
    		undoer = new Undoer(initialTdl);
    	} return undoer;
    }
    
    private Undoer() {
		init(new ToDoList());
    }
    
    public static Undoer getInstance() {
    	if (undoer == null) {
    		undoer = new Undoer();
    	} return undoer;
    }
    
	
	private void init(ReadOnlyToDoList initialTdl) {
		undoList = new Stack<ReadOnlyToDoList>();
		undoList.push(initialTdl);
		redoList = new Stack<ReadOnlyToDoList>();
		ec = EventsCenter.getInstance();
		ec.registerHandler(this);
    }
	
	public ReadOnlyToDoList peekUndoList() {
		return undoList.peek();
	}
	
	/**
	 * Creates a snapshot of the ToDoList and saves it to the stack.
	 * 
	 * @param tdl ToDoList to be saved
	 */
	public void snapshot(ReadOnlyToDoList tdl) {
		undoList.push(tdl);
	}
	
	public ReadOnlyToDoList undo(ToDoList currentState) throws EmptyStackException {
		if (undoList.size() <= 1 )
			throw new EmptyStackException();
		ReadOnlyToDoList topmost = undoList.pop();
		redoList.push(currentState);
		return topmost;	
	}
	
	public ReadOnlyToDoList redo(ToDoList currentState) throws EmptyStackException {
		if (redoList.size() <= 0)
			throw new EmptyStackException();
		ReadOnlyToDoList topmost = redoList.pop();
		undoList.push(currentState);
		return topmost;
	}

	public void clearRedoStack() {
		redoList.removeAllElements();
	}
}
```
###### /java/seedu/cmdo/storage/StorageManager.java
``` java
    /**
     * Updates the user prefs file with filePath change.
     * 
     * @param filePath
     * @throws DataConversionException
     * @throws IOException
     */
    @Override
    public void updateFilePathInUserPrefs(String filePath) throws DataConversionException, IOException {
    	Optional<UserPrefs> prefsOptional = userPrefStorage.readUserPrefs();
    	UserPrefs userPrefs = prefsOptional.orElse(new UserPrefs());
    	userPrefs.setStorageSettings(filePath);
    	userPrefStorage.saveUserPrefs(userPrefs);
    	updateFilePathInXmlToDoListStorage(filePath);
    }
    
    private void updateFilePathInXmlToDoListStorage(String filePath) {
    	this.toDoListStorage.setToDoListFilePath(filePath);
    }

    // ================ ToDoList methods ==============================

    @Override
    public String getToDoListFilePath() {
        return toDoListStorage.getToDoListFilePath();
    }

    @Override
    public Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, FileNotFoundException {
        logger.fine("Attempting to read data from file: " + toDoListStorage.getToDoListFilePath());

        return toDoListStorage.readToDoList(toDoListStorage.getToDoListFilePath());
    }

    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList) throws IOException {
        toDoListStorage.saveToDoList(toDoList, toDoListStorage.getToDoListFilePath());
    }


    @Override
    @Subscribe
    public void handleToDoListChangedEvent(ToDoListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveToDoList(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

}
```
###### /java/seedu/cmdo/storage/XmlAdaptedTask.java
``` java
    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        // Settle the range first.
        final DueByDate dbd;
        final DueByTime dbt;
        
        String[] tokenizedDateRange = tokenizeTo(dueByDate);
        if (tokenizedDateRange.length == 2) {
        	dbd = new DueByDate(LocalDate.parse(tokenizedDateRange[0]), LocalDate.parse(tokenizedDateRange[1]));
        } else dbd = new DueByDate(LocalDate.parse(this.dueByDate));
        
        String[] tokenizedTimeRange = tokenizeTo(dueByTime);
        if (tokenizedTimeRange.length == 2) {
        	dbt = new DueByTime(LocalTime.parse(tokenizedTimeRange[0]), LocalTime.parse(tokenizedTimeRange[1]));
        } else dbt = new DueByTime(LocalTime.parse(this.dueByTime));
        
        // Settle the other parameters.
        final Detail detail = new Detail(this.detail);
        final Done done = new Done(Boolean.parseBoolean(this.done));
        final Priority priority = new Priority(this.priority);
        final boolean block = Boolean.parseBoolean(this.block);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(detail, done, dbd, dbt, priority, block, tags);
    }
    
```
###### /java/seedu/cmdo/storage/XmlAdaptedTask.java
``` java
    private String[] tokenizeTo(String input) {
    	return input.split("/to/");
    }
}
```
###### /java/seedu/cmdo/storage/XmlToDoListStorage.java
``` java
    public void setToDoListFilePath(String filePath){
    	this.filePath = filePath;
    }

    /**
     * Similar to {@link #readToDoList()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyToDoList> readToDoList(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File toDoListFile = new File(filePath);

        if (!toDoListFile.exists()) {
            logger.info("ToDoList file "  + toDoListFile + " not found");
            return Optional.empty();
        }

        ReadOnlyToDoList toDoListOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(toDoListOptional);
    }

    /**
     * Similar to {@link #saveToDoList(ReadOnlyToDoList)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveToDoList(ReadOnlyToDoList toDoList, String filePath) throws IOException {
        assert toDoList != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableToDoList(toDoList));
    }

    @Override
    public Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, IOException {
        return readToDoList(filePath);
    }

    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList) throws IOException {
        saveToDoList(toDoList, filePath);
    }
}
```
###### /java/seedu/cmdo/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleStorageFileChangedEvent(StorageFileChangedEvent sfce) {
    	setSaveLocation(sfce.getFilePath());
    }
}
```
###### /java/seedu/cmdo/ui/TaskCategory.java
``` java
    public void updateTasksOverviewPanel(ObservableList<ReadOnlyTask> taskObservableList) {
        List<Integer> countMap = getTaskTimeStateCount(taskObservableList);
        
    	//Integer tasksInInbox = 0;
        Integer overdueNumber = 0;
        Integer todayNumber = 0;
        Integer thisWeekNumber = 0;
        Integer thisMonthNumber = 0;
        Integer somedayNumber = 0;
        Integer doneNumber = 0;
        Integer totalTasksNumber = 0;
        
        for (Integer i:countMap) {
        	switch (i) {
        	case 666:
        		doneNumber++;
        		break;
        	case -1:
        		overdueNumber++;
        		break;
        	case 0:
        		somedayNumber++;
        		break;
        	case 1:
        		todayNumber++;
        	case 2:
        		thisWeekNumber++;
        	case 3:
        		thisMonthNumber++;
        	}
        }
        overDueNo.setText("[" + Integer.toString(overdueNumber) + "]");
        overDueNo.setFont(new Font(null, 20));
        todayNo.setText("[" + Integer.toString(todayNumber) + "]");
        todayNo.setFont(new Font(null, 20));
        thisWeekNo.setText("[" + Integer.toString(thisWeekNumber) + "]");
        thisWeekNo.setFont(new Font(null, 20));
        thisMonthNo.setText("[" + Integer.toString(thisMonthNumber) + "]");
        thisMonthNo.setFont(new Font(null, 20));
        somedayNo.setText("[" + Integer.toString(somedayNumber) + "]");
        somedayNo.setFont(new Font(null, 20));
        totalTasksNumber = taskObservableList.size() - doneNumber;
        totalTaskNo.setText("[" + Integer.toString(totalTasksNumber) + "]");
        totalTaskNo.setFont(new Font(null, 20));
        totalDoneNo.setText("[" + Integer.toString(doneNumber) + "]"); 
        totalDoneNo.setFont(new Font(null, 20));
    }

```
###### /java/seedu/cmdo/ui/TaskCategory.java
``` java
    /**
     * Determines the time-state of the task in question
     * 
     * =======TIME-STATE TABLE=======
     * |    state   |   due         |
     * |------------|---------------|
     * |    404     |   error       |
     * |    666     |   done        |
     * |    -1      |   overdue     |
     * |    0       |   no due date |
     * |    1       |   today       |
     * |    2       |   this week   |
     * |    3       |   this month  |
     * ==============================
     * 
     * @param task (undone) in question
     * @return Integer based on the time-state
     */
    public Integer getTaskTimeState(ReadOnlyTask task) {
    	assert task != null;
    	
    	if (task.checkDone().value) {
    		return 666;
    	}
    	
        DueByDate dbd = task.getDueByDate();
        
        LocalDate nowDate = LocalDate.now();
        LocalDate weekDate = nowDate.plusWeeks(1);
        LocalDate monthDate = nowDate.plusMonths(1);
        LocalDate dueDate = dbd.start;
        
        // Floating tasks.
        if (dueDate.equals(LocalDate.MIN)) {
            return 0;
        }
        
        if (dueDate.isBefore(nowDate)) return -1;
        if (dueDate.isEqual(nowDate)) return 1;
        if (dueDate.isBefore(weekDate)) return 2;
        if (dueDate.isBefore(monthDate)) return 3;
        
        return 404;
    }
    
```
###### /java/seedu/cmdo/ui/TaskCategory.java
``` java
    public List<Integer> getTaskTimeStateCount(ObservableList<ReadOnlyTask> taskObservableList) {
        assert taskObservableList != null;
    	List<Integer> countMap = new ArrayList<Integer>();
        for (ReadOnlyTask t:taskObservableList) {
            countMap.add(getTaskTimeState(t));        
        }
        return countMap;
    }
    
```
