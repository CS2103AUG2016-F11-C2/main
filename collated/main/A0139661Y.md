# A0139661Y
###### /java/seedu/cmdo/commons/events/ui/StorageFileChangedEvent.java
``` java
 */
public class StorageFileChangedEvent extends BaseEvent {
	
	private String filePath;
	
	public StorageFileChangedEvent(String filePath) {
		this.filePath = filePath;
	}

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public String getFilePath() {
    	return filePath;
    }
}
```
###### /java/seedu/cmdo/commons/exceptions/CannotUndoException.java
``` java
public class CannotUndoException extends Exception {
	public CannotUndoException(String message) {
		super(message);
	}
}
```
###### /java/seedu/cmdo/commons/util/SearchUtil.java
``` java
    public static boolean containsIgnoreCase(UniqueTagList source, String query) {
    	ArrayList<String> strings = new ArrayList<String>(); 
    	for (Tag t : source) {
    		strings.add(t.tagName);
        }    	
        return strings.stream().filter(s -> s.contains(query.toLowerCase())).count() > 0;
    }

    /**
     * Queries the task in question for date and time based on the user's NLP input.
     * 
     * @param dbd
     * @param dbt
     * @param query
     * @return boolean
     * 
```
###### /java/seedu/cmdo/commons/util/SearchUtil.java
``` java
     */
    public static boolean containsTimeAndDate(DueByDate dbd, DueByTime dbt, String query) {
    	Parser parser = new Parser();
    	List<DateGroup> dtl = parser.parse(query);
    	ArrayList<LocalDate> userDates = new ArrayList<LocalDate>();
    	ArrayList<LocalTime> userTimes = new ArrayList<LocalTime>();
    	for (DateGroup dg : dtl) {
    		List<Date> dl = dg.getDates();
    		for (Date d : dl) {
    			LocalDate ld = d.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
    			LocalTime lt = d.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();
    			userDates.add(ld);
    			userTimes.add(lt);
    		}
    	}
    	// User time will never be empty so there is no time
    	if (userTimes.isEmpty()) return false;
    	ArrayList<LocalDate> dates = new ArrayList<LocalDate>();
    	ArrayList<LocalTime> times = new ArrayList<LocalTime>(); 
    	if (dbt.isRange()) {
    		times.add(dbt.end);
    	} if (!dbt.isFloating()) {
    		times.add(dbt.start);
    	} if (dbd.isRange()) {
    		dates.add(dbd.end);
    	} if (!dbd.isFloating()) {
    		dates.add(dbd.start);
    	}
    	if (dates.contains(LocalDate.now())) {
    		return times.stream().filter(s -> userTimes.contains(s)).count() > 0;
    	}
    	return times.stream().filter(s -> userTimes.contains(s)).count() > 0 
    			|| dates.stream().filter(s -> userDates.contains(s)).count() > 0; 
    }
}
```
###### /java/seedu/cmdo/logic/commands/AddCommand.java
``` java
     */
    public AddCommand(String details,
                      LocalDate dueByDate,
                      LocalTime dueByTime,
                      String priority,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Detail(details),
                new DueByDate (dueByDate),
                new DueByTime(dueByTime),
                new Priority(priority),
                new UniqueTagList(tagSet)
        );
        isUndoable = true;
    }
    
    /**
     * Created an add command for RANGE DATE AND TIME
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * 
```
###### /java/seedu/cmdo/logic/commands/AddCommand.java
``` java
     */
    public AddCommand(String details,
                      LocalDate dueByDateStart,
                      LocalTime dueByTimeStart,
                      LocalDate dueByDateEnd,
                      LocalTime dueByTimeEnd,
                      String priority,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Detail(details),
                new DueByDate (dueByDateStart, dueByDateEnd),
                new DueByTime(dueByTimeStart, dueByTimeEnd),
                new Priority(priority),
                new UniqueTagList(tagSet)
        );
        isUndoable = true;
    }


    public AddCommand(Task toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyTask getTask() {
        return toAdd;
    }

    @Override
    public CommandResult execute() {
        Blocker blocker = new Blocker();
    	try {
    		// Check for block conflicts. Throws a TaskBlockedException if conflicts exist.
    		blocker.checkBlocked(toAdd, model.getBlockedList());
        	model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (TaskBlockedException tbe) {
    		return new CommandResult(tbe.getMessage());
        }
    }
}
```
###### /java/seedu/cmdo/logic/commands/StorageCommand.java
``` java
public class StorageCommand extends Command {
	
    public static final String COMMAND_WORD = "storage";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the storage folder path of CMDo.\n"
            + "Parameters: <file/path/name>"
            + "Example: " + COMMAND_WORD
            + " /home/Documents";

    public static final String MESSAGE_SUCCESS = "cmdo.xml now saves to %1$s";

    private final String filePath;

    /**
     * Created an command to change storage filepath.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * 
```
###### /java/seedu/cmdo/logic/commands/StorageCommand.java
``` java
     */
    public StorageCommand(String filePath) {
    	this.filePath = filePath;
    }

    @Override
    public CommandResult execute() {
    	model.changeStorageFilePath(filePath);
        EventsCenter.getInstance().post(new StorageFileChangedEvent(filePath));
        return new CommandResult(String.format(MESSAGE_SUCCESS, filePath));
    }
}
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getBlockedList() {
    	return model.getBlockedList();
    }
    
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getAllTaskList() {
    	return model.getAllTaskList();
    }
    
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
    
```
###### /java/seedu/cmdo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList(boolean firstRun) {
        return model.getFilteredTaskList(firstRun);
    }    
}
```
###### /java/seedu/cmdo/logic/parser/Blocker.java
``` java
	public ArrayList<LocalDateTime> checkBlocked(Task toCheck, UnmodifiableObservableList<ReadOnlyTask> blockedList)
										throws TaskBlockedException {
		ArrayList<LocalDateTime> dateTimeList = new ArrayList<LocalDateTime>();
		if (toCheck.isRange()) {
			LocalDateTime startDt = LocalDateTime.of(toCheck.getDueByDate().start, toCheck.getDueByTime().start);
			LocalDateTime endDt = LocalDateTime.of(toCheck.getDueByDate().end, toCheck.getDueByTime().end);
			dateTimeList.add(startDt);
			dateTimeList.add(endDt);
		} else {
    		LocalDateTime dt = LocalDateTime.of(toCheck.getDueByDate().start, toCheck.getDueByTime().start);
    		dateTimeList.add(dt);
		}
        if (isBlocked(dateTimeList, blockedList)) {
        	throw new TaskBlockedException(Messages.MESSAGE_TIMESLOT_BLOCKED);
        }
        return dateTimeList;
	}
	
	/**
	 * Checks to see if a local date time array list of ranges falls within a blocked slot.
	 * 
	 * @param datesAndTimes
	 * @return boolean based on outcome
	 * 
```
###### /java/seedu/cmdo/logic/parser/Blocker.java
``` java
	 */
	public boolean isBlocked(List<LocalDateTime> datesAndTimes, UnmodifiableObservableList<ReadOnlyTask> blockedList) {
		reset();
		for (LocalDateTime dt : datesAndTimes) {
			logger.info(String.format("Checking before is %s", checking.toString()));
			checkingDate = dt.toLocalDate();
			checkingTime = dt.toLocalTime();
			checking = LocalDateTime.of(checkingDate, checkingTime);
			logger.info(String.format("Checking after is %s", checking.toString()));
			for (ReadOnlyTask rot : blockedList) {
				againstStart = LocalDateTime.of(rot.getDueByDate().start, rot.getDueByTime().start);
				againstEnd = LocalDateTime.of(rot.getDueByDate().end, rot.getDueByTime().end);
				logger.info(String.format("AgainstStart is %s", againstStart.toString()));
				logger.info(String.format("AgainstEnd is %s", againstEnd.toString()));
				if ((checking.isAfter(againstStart) && checking.isBefore(againstEnd))
						|| checking.isEqual(againstStart) 
						|| checking.isEqual(againstEnd)) {
					logger.info("Date is between blocked range.");
					return true; 
				}
			}
		}
		return false;
	}
	
	/**
	 * Resets values such that each time the Blocker is called we start fresh
	 * 
```
###### /java/seedu/cmdo/logic/parser/Blocker.java
``` java
	 */
	private void reset() {
		checkingDate = LocalDate.MAX;
		checkingTime = LocalTime.MAX;
		checking = LocalDateTime.MAX;
		againstStart = LocalDateTime.MIN;
		againstEnd = LocalDateTime.MIN;
	}
}
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private void init() {
    	parser = new Parser();
    	datesAndTimes = new ArrayList<LocalDateTime>();
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
    	String[] splitedInput = userInput.split("\\s+");
    	String commandWord, arguments; 
    	if(splitedInput.length == 2 && 
    			((splitedInput[1].equals("done")) || (splitedInput[1].equals("all")) || splitedInput[1].equals("block"))) {
    		Matcher matcher = LIST_COMMAND_FORMAT.matcher(userInput.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }
            commandWord = matcher.group("commandWord");
            arguments = matcher.group("arguments");
    	}
    	else{
    		Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }
            commandWord = matcher.group("commandWord");
            arguments = matcher.group("arguments");
            
    	}
    	arguments = getCleanString(arguments);
        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);
       
        case BlockCommand.COMMAND_WORD:
            return prepareBlock(arguments);

        case SelectCommand.COMMAND_WORD:
            return prepareSelect(arguments);

        case StorageCommand.COMMAND_WORD:
        	return prepareStorage(arguments);
            
        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);
            
        case DoneCommand.COMMAND_WORD:
            return prepareDone(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();
            
        case RedoCommand.COMMAND_WORD:
            return new RedoCommand();
            
        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();
            
        case EditCommand.COMMAND_WORD:
        	return prepareEdit(arguments);

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);
            
        case ListCommand.COMMAND_WORD_DONE:	
        case ListCommand.COMMAND_WORD_SHORT_DONE:
            return prepareList("--done");
        case ListCommand.COMMAND_WORD_BLOCK:
        case ListCommand.COMMAND_WORD_SHORT_BLOCK:
        	return prepareList("--block");
        case ListCommand.COMMAND_WORD:
        case ListCommand.COMMAND_WORD_ALL:        	
        case ListCommand.COMMAND_WORD_SHORT_ALL:
        	return prepareList(arguments);
            
        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

    /**
     * Ensures that file paths are presented properly.
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private Command prepareStorage(String args) {
    	if (args.equals("")) {
    		return new StorageCommand("data/cmdo.xml");
    	}
    	if (args.lastIndexOf("/cmdo.xml") == -1) {
    		args = new StringBuilder(args + "/cmdo.xml").toString();
    	}
    	return new StorageCommand(args);
    }
    
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private Command prepareAdd(String args){
    	datesAndTimes.clear();
    	try {
        	args = extractDetail(args);	// Saves to detailToAdd
        	args = extractDueByDateAndTime(args);
        	if (args.contains("/") && !args.contains(" /")) // Checks for accidental '/' instead of ' /'
        		throw new IllegalValueException(Messages.MESSAGE_INVALID_PRIORITY_SPACE);
        	LocalDateTime dt = LocalDateTime.MIN;
        	LocalDateTime dtStart = LocalDateTime.MIN;
        	LocalDateTime dtEnd = LocalDateTime.MIN;
        	String[] splittedArgs = getCleanString(args).split(" ");
        	// used as flag for task type. 0 for floating, 1 for non-range, 2 for range
        	int dataMode;
        	if (datesAndTimes.size() == 1) {
        		dt = datesAndTimes.get(0);
        		dataMode = 1;
        	} else if (datesAndTimes.size() == 2) {
        		dtStart = datesAndTimes.get(0);
        		dtEnd = datesAndTimes.get(1);
        		dataMode = 2;
        	} else {
        		dt = LocalDateTime.of(NO_DATE_DEFAULT, NO_TIME_DEFAULT);
        		dataMode = 0;
        	}
    		if (dataMode <= 1) {
    			return new AddCommand(
    					detailToAdd,
    					dt.toLocalDate(),
    					dt.toLocalTime(),
    					extractPriority(splittedArgs),
    					getTagsFromArgs(splittedArgs));
    		} else {
    			return new AddCommand(
    					detailToAdd,
    					dtStart.toLocalDate(),
    					dtStart.toLocalTime(),
    					dtEnd.toLocalDate(),
    					dtEnd.toLocalTime(),
    					extractPriority(splittedArgs),
    					getTagsFromArgs(splittedArgs));
    		}
    	} catch (IllegalValueException ive) {
    		return new IncorrectCommand(ive.getMessage());
    	}
    }
    /**
     * Parses arguments in the context of the block task command.
     * 
     * @param args full command args string
     * @return the prepared command
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private Command prepareList(String args) {
        int type = 0; // we assume the user is searching for undone tasks
        if (args.contains("--done")) {
        	type = 1;
        } else if (args.contains("--block")) {
        	type = 2;
        }
        return new ListCommand(type);
    }
    
    /**
     * Utility method which replaces all redundant spaces
     * @param args an uncleaan string
     * @return a cleaned up string
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private String getCleanString(String args) {
    	return args.trim().replaceAll("\\s+", " ");
    }
    
//    ============== HELPER METHODS
    /**
     * Extracts the detail embedded in user input ' '.
     * 
     * @throws IllegalValueException if only one ' found
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private static String extractDetail(String args) throws IllegalValueException {
    	// Check if only one ' used
    	if (args.lastIndexOf("'") == args.indexOf("'"))
    		throw new IllegalValueException(MESSAGE_ENCAPSULATE_DETAIL_WARNING);
    	// Check if detail is empty.
    	if (args.lastIndexOf("'") == args.indexOf("'")+1) {
    		throw new IllegalValueException(MESSAGE_BLANK_DETAIL_WARNING);
    	}
    	// Split into '  ...  '
    	String[] details = args.split("^ '(.+)'$");
    	// Details only, get rid of anything after the '
    	String output = new StringBuilder(details[0]).replace(details[0].lastIndexOf("'"), 
    													details[0].length(), 
    													"").toString();
    	// Get rid of the first '
    	output = output.replaceFirst("'","");
    	// Save to instance
    	detailToAdd = output;
    	
    	// return rear end
    	return new StringBuilder(details[0]).substring(details[0].lastIndexOf("'")+1).toString();
    }
    
	/**
     * Extracts the priority out of the args.
     * If / precedes neither high, medium or low, it will throw an error
     * Otherwise, it is taken to have default no priority.
     * 
     * @param splittedArgs an array of split user input
     * @return priority level string.
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */ 
    private String extractPriority(String[] splittedArgs) throws IllegalValueException {
    	List<String> rawArgs = Arrays.asList(splittedArgs);
    	for (String rawArg : rawArgs) {
    		if (rawArg.toLowerCase().startsWith("/")) {
    			switch(rawArg.replace("/", "")) {
    			case Priority.HIGH:
    				return Priority.HIGH;
    			case Priority.MEDIUM:
    				return Priority.MEDIUM;
    			case Priority.LOW:
    				return Priority.LOW;
    			default:
    				throw new IllegalValueException(MESSAGE_INVALID_PRIORITY);
    			}
    		}
    	}
    	return "";
    }
    
    /**
     * Extracts the dueByDate and dueByTime out of the args.
     * 
     * This snippet of code uses natty by Joel Ostenmach and its implementation was inspired by
     * 
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    public String extractDueByDateAndTime(String dirtyArgs) {
    	List<DateGroup> groups = parser.parse(dirtyArgs);
    	String cleanArgs = dirtyArgs;
    	
    	try {
    		// This retrieves either the start date/time, or the only date/time.
    		for (int i=0; i<groups.size(); i++) {
	    		DateGroup group = groups.get(i);
	    		List<Date> dateList = group.getDates(); 	// Extract date
	    		Map<String, List<ParseLocation>> parseMap = group.getParseLocations();
	    		if ((!parseMap.containsKey("explicit_time") && parseMap.containsKey("relative_date")) || 
	    				(!parseMap.containsKey("explicit_time") && parseMap.containsKey("formal_date"))) {
	    			for (Date date : dateList) {
	    				LocalDateTime temp = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
	    				datesAndTimes.add(LocalDateTime.of(temp.toLocalDate(), LocalTime.MAX));
	    			}
	    		} else {
	    			for (Date date : dateList) {
	    				datesAndTimes.add(LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault()));
	    			}
	    		}
	    		for (ParseLocation parsedWord : parseMap.get("parse")) {
	    			cleanArgs = cleanArgs.substring(0, parsedWord.getStart() - 1) + cleanArgs.substring(parsedWord.getEnd() -1);
	    		}
    		}
    		// Sort dates and times according to whichever is earlier
    		Collections.sort(datesAndTimes);
    		return cleanArgs;	// Return a cleaned up string
    	} catch (IndexOutOfBoundsException e) {
    		return dirtyArgs;
    	}
    }
    
    /**
     * Checks for non-essential groups.
     * 
     * @author A0139661Y-unused
     */
    private static String checkEmpty(String argument) {
    	if (argument.isEmpty()) {
    		return "";
    	} return argument;
    }

    /**
     * Extracts the new task's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String[] splittedArgs) throws IllegalValueException {
    	List<String> rawArgs = Arrays.asList(splittedArgs);
    	Collection<String> tagStrings = new ArrayList<String>();
    	boolean isEmpty = true;
    	for (String rawArg : rawArgs) {
    		isEmpty = false;
    		if (rawArg.startsWith("-")) {
    			tagStrings.add(rawArg.replace("-", ""));
    		}
    	}
    	if (isEmpty) {
    		return Collections.emptySet();
    	} 
    	return new HashSet<>(tagStrings);
    }
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));
    }
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     *   Returns an {@code Optional.empty()} otherwise.
     *   
```
###### /java/seedu/cmdo/logic/parser/MainParser.java
``` java
     */
    private Optional<Integer> parseLooseIndex(String command) {
        final Matcher matcher = TASK_LOOSE_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));
    } 
}
```
###### /java/seedu/cmdo/MainApp.java
``` java
     */
	private void syncUserPrefsToConfig() throws Exception {
        config.setToDoListFilePath(userPrefs.getStorageSettings().getFilePath());
        storage.updateFilePathInUserPrefs(config.getToDoListFilePath());
        storage.saveToDoList(model.getToDoList());
	}

    private String getApplicationParameter(String parameterName){
        Map<String, String> applicationParameters = getParameters().getNamed();
        return applicationParameters.get(parameterName);
    }

    private Model initModelManager(Storage storage, UserPrefs userPrefs) {
        Optional<ReadOnlyToDoList> toDoListOptional;
        ReadOnlyToDoList initialData;
        try {
            toDoListOptional = storage.readToDoList();
            if(!toDoListOptional.isPresent()){
                logger.info("Data file not found. Will be starting with an empty ToDoList");
            }
            initialData = toDoListOptional.orElse(new ToDoList());
        } catch (DataConversionException e) {
            logger.warning("Data file not in the correct format. Will be starting with an empty ToDoList");
            initialData = new ToDoList();
        } catch (FileNotFoundException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty ToDoList");
            initialData = new ToDoList();
        } catch(Exception e) {
        	logger.warning("Data file not found. Will be starting with an empty ToDoList");
        	initialData = new ToDoList();
        }

        return new ModelManager(initialData, userPrefs);
    }

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    protected Config initConfig(String configFilePath) {
        Config initializedConfig;
        String configFilePathUsed;

        configFilePathUsed = Config.DEFAULT_CONFIG_FILE;

        if(configFilePath != null) {
            logger.info("Custom Config file specified " + configFilePath);
            configFilePathUsed = configFilePath;
        }

        logger.info("Using config file : " + configFilePathUsed);

        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(configFilePathUsed);
            initializedConfig = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            logger.warning("Config file at " + configFilePathUsed + " is not in the correct format. " +
                    "Using default config properties");
            initializedConfig = new Config();
        }

        //Update config file in case it was missing to begin with or there are new/unused fields
        try {
            ConfigUtil.saveConfig(initializedConfig, configFilePathUsed);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }
        return initializedConfig;
    }

    protected UserPrefs initPrefs(Config config) {
        assert config != null;

        String prefsFilePath = config.getUserPrefsFilePath();
        logger.info("Using prefs file : " + prefsFilePath);

        UserPrefs initializedPrefs;
        try {
            Optional<UserPrefs> prefsOptional = storage.readUserPrefs();
            initializedPrefs = prefsOptional.orElse(new UserPrefs());
        } catch (DataConversionException e) {
            logger.warning("UserPrefs file at " + prefsFilePath + " is not in the correct format. " +
                    "Using default user prefs");
            initializedPrefs = new UserPrefs();
        } catch (IOException e) {
            logger.warning("Problem while reading from the file. . Will be starting with an empty ToDoList");
            initializedPrefs = new UserPrefs();
        }

        // Update prefs file in case it was missing to begin with or there are new/unused fields
        try {
            storage.saveUserPrefs(initializedPrefs);
        } catch (IOException e) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(e));
        }

        return initializedPrefs;
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting ToDoList " + MainApp.VERSION);
        ui.start(primaryStage);
    }

    @Override
    public void stop() {
        logger.info("============================ [ Stopping CMDo ] =============================");
        ui.stop();
        try {
            storage.saveUserPrefs(userPrefs);
        } catch (IOException e) {
            logger.severe("Failed to save preferences " + StringUtil.getDetails(e));
        }
        Platform.exit();
        System.exit(0);
    }
    
    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }
    
    /**
     * Handles an event where the storage file has been changed.
     * @param event
     * 
```
###### /java/seedu/cmdo/MainApp.java
``` java
     */
    @Subscribe
    public void handleStorageFileChangedEvent(StorageFileChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        try {
        	syncUserPrefsToConfig();
        } catch (Exception e) {
        	logger.severe("Failed to update config file.");
        }
    }

    public static void main(String[] args) {
        launch(args);
    }

}
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
        this.undoer = Undoer.getInstance();
        logger.info("Saved new toDoList into Undoer stack. " + toDoList.toString());
    }

    public ModelManager() {
        this(new ToDoList(), new UserPrefs());
    }

    public ModelManager(ReadOnlyToDoList initialData, UserPrefs userPrefs) {
        toDoList = new ToDoList(initialData);
        filteredTasks = new FilteredList<>(toDoList.getTasks());
        this.userPrefs = userPrefs;

```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
        this.undoer = Undoer.getInstance();
        logger.info("Saved last stable toDoList into Undoer stack. " + toDoList.toString());
    }

    @Override
    public void resetData(ReadOnlyToDoList newData) {
    	toDoList.resetData(newData);
        indicateToDoListChanged();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return toDoList;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(toDoList));
    }
    
    /**
     * Undo functionality
     * 
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
     */
    @Override
    public synchronized void undo() throws CannotUndoException {
    	try {
    		ToDoList currentState = new ToDoList(toDoList);
    		toDoList.resetData(undoer.undo(currentState));
    		logger.info("Undo operation called.");
    	} catch (EmptyStackException ese) {
    		throw new CannotUndoException("Nothing to undo.");
    	}
    	indicateToDoListChanged();
    	updateFilteredListToShowAll();
    }
    
    /**
     * Redo functionality
     * 
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public synchronized void doneTask(ReadOnlyTask target, Task replacer) throws TaskNotFoundException, TaskAlreadyDoneException {
        toDoList.removeTask(target);
    	toDoList.addTask(replacer);
        indicateToDoListChanged();
    	updateFilteredListToShowAll();
    }

    @Override
    public synchronized void addTask(Task task) {
        toDoList.addTask(task);
        updateFilteredListToShowAll();
        indicateToDoListChanged();
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public synchronized void editTask(ReadOnlyTask taskToEdit, Task toEditWith) throws TaskNotFoundException {
    	toDoList.editTask(taskToEdit, toEditWith);
    	updateFilteredListToShowAll();
    	indicateToDoListChanged();
    }
    
    @Override
    public void changeStorageFilePath(String filePath) {
    	userPrefs.setStorageSettings(filePath);
    	indicateToDoListChanged();
    }

    //=========== Filtered Task List Accessors ===============================================================
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getAllTaskList() {
    	return new UnmodifiableObservableList<>(toDoList.getTasks());
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
    	return new UnmodifiableObservableList<>(filteredTasks); 
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList(boolean firstRun) {
    	UnmodifiableObservableList<ReadOnlyTask> initList = new UnmodifiableObservableList<>(filteredTasks);
    	// This prevents even done tasks from showing up at first run.
    	updateFilteredListToShowAll(false);
    	return initList;
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override 
    public UnmodifiableObservableList<ReadOnlyTask> getBlockedList() {
    	UnmodifiableObservableList<ReadOnlyTask> initList = new UnmodifiableObservableList<>(filteredTasks);
    	updateFilteredListToShowBlocked();
    	return initList;
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowBlocked() {
        updateFilteredListToShowAll(new PredicateExpression(new BlockQualifier()));
    }
    
    // By default a list with no done tasks where taskStatus is false
    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredListToShowAll(new PredicateExpression(new DetailQualifier()));
    }
    
    // Used by find done or list done where taskStatus is true
    @Override
    public void updateFilteredListToShowAll(boolean taskStatus) {
        updateFilteredListToShowAll(new PredicateExpression(new DetailQualifier(taskStatus)));
    }
    
    private void updateFilteredListToShowAll(Expression expression) {
    	assert expression != null;
    	filteredTasks.setPredicate(expression::satisfies);
    }
    
    // Used by find done <...> or find <...> where taskStatus depends on user input.
    @Override
    public void updateFilteredTaskList(Set<String> keywords, boolean taskStatus){
        updateFilteredTaskList(new PredicateExpression(new DetailQualifier(keywords, taskStatus)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class DetailQualifier implements Qualifier {
        private Set<String> detailKeyWords = Collections.EMPTY_SET;
        private final boolean taskStatus;
        
        // Keywords, specified tasks status
        // Likely a find done <...>
        DetailQualifier(Set<String> detailKeyWords, boolean taskStatus) {
            this.detailKeyWords = detailKeyWords;
            this.taskStatus = taskStatus;
        }
        
        // No keywords, a specified task status
        // Likely a find done or a list done
        DetailQualifier(boolean taskStatus) {
            this.taskStatus = taskStatus;
        }
        
        // No keywords, no specified task status
        // Likely a list
        DetailQualifier() {
        	taskStatus = false;
        }
        
        /*
         * shows only undone tasks
         * 
         * @return boolean: true if match, false if not
         */
        @Override
        public boolean run(ReadOnlyTask task) {
        	// Determine if done tasks match the user's filter criteria.
        	// In this case, no keywords were specified.
        	if (detailKeyWords.isEmpty()) {
        		return task.checkDone().value.equals(taskStatus);
        	}
        	if (task.checkDone().value != taskStatus)
        		return false;
            return detailKeyWords.stream()
                    .filter(keyword -> (SearchUtil.containsIgnoreCase(task.getDetail().details, keyword)
                    					|| SearchUtil.containsIgnoreCase(task.getPriority().value, keyword)
                    					|| SearchUtil.containsIgnoreCase(task.getTags(), keyword)
                    					|| SearchUtil.containsTimeAndDate(task.getDueByDate(), task.getDueByTime(), keyword)))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "detail=" + String.join(", ", detailKeyWords);
        }
    }
    
```
###### /java/seedu/cmdo/model/ModelManager.java
``` java
    private class BlockQualifier implements Qualifier {           
        /*
		 * Produces a list of blocks only.
         * 
         * @return boolean: true if match, false if not
         */
        @Override
        public boolean run(ReadOnlyTask task) {
        	return task.getBlock();
        }
    }
}
```
###### /java/seedu/cmdo/model/task/DueByDate.java
``` java
     */
    public DueByDate(LocalDate dueByDate) throws IllegalValueException {
        assert dueByDate != null;
        this.end = LocalDate.MIN;
        this.start = dueByDate;
        this.isRange = false;
        if (dueByDate.equals(NO_DATE))
        	this.isFloating = true;
    }
    
    /**
     * Takes in a start date and end date.
     *
     * @throws IllegalValueException if given due date string is invalid.
     * 
```
###### /java/seedu/cmdo/model/task/DueByDate.java
``` java
     */
    public DueByDate(LocalDate dueByDateStart, LocalDate dueByDateEnd) {
        assert dueByDateStart != null && dueByDateEnd != null;
        this.start = dueByDateStart;
        this.end = dueByDateEnd;
        this.isRange = true;
    }

    @Override
    public String toString() {
        if (isRange)
        	return new StringBuilder(start.toString() + "/to/" + end.toString()).toString();
        else 
        	return start.toString();
    }
    
    public boolean isRange() {
        return isRange;
    }
    
    public boolean isFloating() {
    	return isFloating;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueByDate // instanceof handles nulls
                && this.equals((DueByDate) other));
    }

    @Override
    public int hashCode() {
    	return Objects.hash(start, end);
    }
    
    /*
     * Produces a friendly string of values in the format MM/DD/YYYY
     * 
```
###### /java/seedu/cmdo/model/task/DueByDate.java
``` java
     */
	public String getFriendlyString() {		
		// If floating date, return do not print anything
		if (start.equals(NO_DATE) && end.equals(NO_DATE))
			return "";
		if (!isRange) {
			return new StringBuilder(start.format(DATE_FORMAT)).toString();
		}
		return new StringBuilder(start.format(DATE_FORMAT) 
								+ " - " 
								+ end.format(DATE_FORMAT))
								.toString();
	}
	
```
###### /java/seedu/cmdo/model/task/DueByDate.java
``` java
	public String getFriendlyStartString() {
		if (isFloating) return "";
		if (!isRange) return start.format(DATE_FORMAT).toString();
		return start.format(DATE_FORMAT).toString(); 
	}
	
```
###### /java/seedu/cmdo/model/task/DueByDate.java
``` java
	public String getFriendlyEndString() {
		if (!isRange || isFloating || end.equals(NO_DATE)) return "";
		return end.format(DATE_FORMAT).toString();
	}
}
```
###### /java/seedu/cmdo/model/task/DueByTime.java
``` java
     */
    public DueByTime(LocalTime dueByTime) throws IllegalValueException {
        assert dueByTime != null;
        // Check for date with time
        if (!dueByTime.equals(NO_TIME)) {
        	this.start = dueByTime.truncatedTo(ChronoUnit.MINUTES);
        } else { 
        	this.start = NO_TIME;
        	this.isFloating = true;
        }
    	this.end = NO_TIME;
    	this.isRange = false;
    }
    
    /**
     * Create a range of dueByTime.
     *
     * @throws IllegalValueException if given dueByTime string is invalid.
     * 
```
###### /java/seedu/cmdo/model/task/DueByTime.java
``` java
     */
    public DueByTime(LocalTime dueByTimeStart, LocalTime dueByTimeEnd) throws IllegalValueException {
        assert dueByTimeStart != null && dueByTimeEnd != null;
        // Enable storage of floating time in date range
        if (dueByTimeStart.equals(NO_TIME) && dueByTimeEnd.equals(NO_TIME)) {
        	this.start = NO_TIME;
        	this.end = start;
        	this.isFloating = true;
        } else {
        	this.start = dueByTimeStart.truncatedTo(ChronoUnit.MINUTES);
        	this.end = dueByTimeEnd.truncatedTo(ChronoUnit.MINUTES);
        }
        this.isRange = true;
    }

    @Override
    public String toString() {
        if (isRange)
        	return new StringBuilder(start.toString() + "/to/" + end.toString()).toString();
        else 
        	return start.toString();
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueByTime // instanceof handles nulls
                && this.equals((DueByTime) other)); 
    }
    
```
###### /java/seedu/cmdo/model/task/DueByTime.java
``` java
    public boolean isRange() {
		return isRange;
	}
    
    public boolean isFloating() {
    	return isFloating;
    }
    
    /*
     * Produces a friendly string of values in the format HH:MM
     * 
```
###### /java/seedu/cmdo/model/task/DueByTime.java
``` java
     */
    public String getFriendlyString() {
		// If floating date, return do not print anything
		if (start.equals(NO_TIME) && end.equals(NO_TIME)) {
			return "";
		}
    	if (!isRange) {
    		return new StringBuilder(start.format(TIME_FORMAT)).toString();
    	}
		return new StringBuilder(start.format(TIME_FORMAT) 
				+ " - " 
				+ end.format(TIME_FORMAT))
				.toString();
	}
    
```
###### /java/seedu/cmdo/model/task/DueByTime.java
``` java
	public String getFriendlyStartString() {
		if (!isRange && isFloating)
			return "";
		return start.format(TIME_FORMAT).toString(); 
	}
	
```
###### /java/seedu/cmdo/model/task/DueByTime.java
``` java
	public String getFriendlyEndString() {
		if (!isRange) {
			return "";
		}
		if (end.equals(NO_TIME)) {
			return "";
		} else return end.format(TIME_FORMAT).toString();
	}
}
```
###### /java/seedu/cmdo/model/task/Task.java
``` java
     */
    public Task(ReadOnlyTask source, Done done) {
        this(source.getDetail(), done, source.getDueByDate(), source.getDueByTime(), source.getPriority(), source.getBlock(), source.getTags());
    }


    
```
###### /java/seedu/cmdo/model/task/UniqueTaskList.java
``` java
     */
    public static class TaskAlreadyDoneException extends Exception {}

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty TaskList.
     */
    public UniqueTaskList() {}

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) {
        assert toAdd != null;
        internalList.add(toAdd);
    }

    /**
     * Retrieves the equivalent task in the list for editing.
     *
     * @throws TaskNotFoundException
     * @author A0139661Y
     */
    public void edit(ReadOnlyTask toEdit, Task toEditWith) throws TaskNotFoundException {
    	assert (toEdit != null && toEditWith != null);
    	int index = internalList.indexOf(toEdit);
    	if (index == -1) {
    		throw new TaskNotFoundException();
    	}
    	internalList.set(index, toEditWith);
//    	internalList.remove(toEdit);
//    	internalList.add(toEditWith);
    }
    
    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }
}
```
###### /java/seedu/cmdo/model/ToDoList.java
``` java
    public ToDoList(ArrayList<ReadOnlyTask> tasks, UniqueTagList tags) {
    	resetData(FXCollections.observableList(tasks), tags.getInternalList());
    }

    public static ReadOnlyToDoList getEmptyToDoList() {
        return new ToDoList();
    }

//// list overwrite operations

    public ObservableList<Task> getTasks() {
        return tasks.getInternalList();
    }

    public void setTasks(List<Task> tasks) {
        this.tasks.getInternalList().setAll(tasks);
    }

    public void setTags(Collection<Tag> tags) {
        this.tags.getInternalList().setAll(tags);
    }

    public void resetData(Collection<? extends ReadOnlyTask> newTasks, Collection<Tag> newTags) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setTags(newTags);
    }

    public void resetData(ReadOnlyToDoList newData) {
        resetData(newData.getTaskList(), newData.getTagList());
    }

//// Task-level operations

    /**
     * Adds a Task to the address book.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task t) {
        syncTagsWithMasterList(t);
        tasks.add(t);
    }
    
    /**
     * Edits a Task in the address book.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the tast to oint to those in {@link @tags}.
     * 
     * @author A0139661Y
     */
    public void editTask(ReadOnlyTask toEdit, Task toEditWith) throws UniqueTaskList.TaskNotFoundException {
    	// Add tags from replacing task
    	syncTagsWithMasterList(toEditWith);
    	tasks.edit(toEdit, toEditWith);
    	
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncTagsWithMasterList(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        for (Tag tag : tags) {
            masterTagObjects.put(tag, tag);
        }

        // Rebuild the list of task tags using references from the master list
        final Set<Tag> commonTagReferences = new HashSet<>();
        for (Tag tag : taskTags) {
            commonTagReferences.add(masterTagObjects.get(tag));
        }
        task.setTags(new UniqueTagList(commonTagReferences));
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return tasks.getInternalList().size() + " tasks, " + tags.getInternalList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyTask> getTaskList() {
        return Collections.unmodifiableList(tasks.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasks;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ToDoList // instanceof handles nulls
                && this.tasks.equals(((ToDoList) other).tasks)
                && this.tags.equals(((ToDoList) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, tags);
    }
}
```
###### /java/seedu/cmdo/model/Undoer.java
``` java
	 */
	public void snapshot(ReadOnlyToDoList tdl) {
		undoList.push(tdl);
	}
	
	//@@ author A0139661Y
	public ReadOnlyToDoList undo(ToDoList currentState) throws EmptyStackException {
		if (undoList.size() <= 1 )
			throw new EmptyStackException();
		ReadOnlyToDoList topmost = undoList.pop();
		redoList.push(currentState);
		return topmost;	
	}
	
```
###### /java/seedu/cmdo/storage/StorageManager.java
``` java
     */
    @Override
    public void updateFilePathInUserPrefs(String filePath) throws DataConversionException, IOException {
    	Optional<UserPrefs> prefsOptional = userPrefStorage.readUserPrefs();
    	UserPrefs userPrefs = prefsOptional.orElse(new UserPrefs());
    	userPrefs.setStorageSettings(filePath);
    	userPrefStorage.saveUserPrefs(userPrefs);
    	updateFilePathInXmlToDoListStorage(filePath);
    }
    
    private void updateFilePathInXmlToDoListStorage(String filePath) {
    	this.toDoListStorage.setToDoListFilePath(filePath);
    }

    // ================ ToDoList methods ==============================

    @Override
    public String getToDoListFilePath() {
        return toDoListStorage.getToDoListFilePath();
    }

    @Override
    public Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, FileNotFoundException {
        logger.fine("Attempting to read data from file: " + toDoListStorage.getToDoListFilePath());

        return toDoListStorage.readToDoList(toDoListStorage.getToDoListFilePath());
    }

    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList) throws IOException {
        toDoListStorage.saveToDoList(toDoList, toDoListStorage.getToDoListFilePath());
    }


    @Override
    @Subscribe
    public void handleToDoListChangedEvent(ToDoListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            saveToDoList(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

}
```
###### /java/seedu/cmdo/storage/XmlAdaptedTask.java
``` java
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        
        // Settle the range first.
        final DueByDate dbd;
        final DueByTime dbt;
        
        String[] tokenizedDateRange = tokenizeTo(dueByDate);
        if (tokenizedDateRange.length == 2) {
        	dbd = new DueByDate(LocalDate.parse(tokenizedDateRange[0]), LocalDate.parse(tokenizedDateRange[1]));
        } else dbd = new DueByDate(LocalDate.parse(this.dueByDate));
        
        String[] tokenizedTimeRange = tokenizeTo(dueByTime);
        if (tokenizedTimeRange.length == 2) {
        	dbt = new DueByTime(LocalTime.parse(tokenizedTimeRange[0]), LocalTime.parse(tokenizedTimeRange[1]));
        } else dbt = new DueByTime(LocalTime.parse(this.dueByTime));
        
        // Settle the other parameters.
        final Detail detail = new Detail(this.detail);
        final Done done = new Done(Boolean.parseBoolean(this.done));
        final Priority priority = new Priority(this.priority);
        final boolean block = Boolean.parseBoolean(this.block);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(detail, done, dbd, dbt, priority, block, tags);
    }
    
    private String[] tokenizeTo(String input) {
    	return input.split("/to/");
    }
}
```
###### /java/seedu/cmdo/storage/XmlToDoListStorage.java
``` java
    public void setToDoListFilePath(String filePath){
    	this.filePath = filePath;
    }

    /**
     * Similar to {@link #readToDoList()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     */
    public Optional<ReadOnlyToDoList> readToDoList(String filePath) throws DataConversionException, FileNotFoundException {
        assert filePath != null;

        File toDoListFile = new File(filePath);

        if (!toDoListFile.exists()) {
            logger.info("ToDoList file "  + toDoListFile + " not found");
            return Optional.empty();
        }

        ReadOnlyToDoList toDoListOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(toDoListOptional);
    }

    /**
     * Similar to {@link #saveToDoList(ReadOnlyToDoList)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveToDoList(ReadOnlyToDoList toDoList, String filePath) throws IOException {
        assert toDoList != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableToDoList(toDoList));
    }

    @Override
    public Optional<ReadOnlyToDoList> readToDoList() throws DataConversionException, IOException {
        return readToDoList(filePath);
    }

    @Override
    public void saveToDoList(ReadOnlyToDoList toDoList) throws IOException {
        saveToDoList(toDoList, filePath);
    }
}
```
###### /java/seedu/cmdo/ui/TaskCategory.java
``` java
    public void updateTasksOverviewPanel(ObservableList<ReadOnlyTask> taskObservableList) {
        List<Integer> countMap = getTaskTimeStateCount(taskObservableList);
        
    	//Integer tasksInInbox = 0;
        Integer overdueNumber = 0;
        Integer todayNumber = 0;
        Integer thisWeekNumber = 0;
        Integer thisMonthNumber = 0;
        Integer somedayNumber = 0;
        Integer doneNumber = 0;
        Integer totalTasksNumber = 0;
        
        for (Integer i:countMap) {
        	switch (i) {
        	case 666:
        		doneNumber++;
        		break;
        	case -1:
        		overdueNumber++;
        		break;
        	case 0:
        		somedayNumber++;
        		break;
        	case 1:
        		todayNumber++;
        	case 2:
        		thisWeekNumber++;
        	case 3:
        		thisMonthNumber++;
        	}
        }
        overDueNo.setText("[" + Integer.toString(overdueNumber) + "]");
        todayNo.setText("[" + Integer.toString(todayNumber) + "]");
        thisWeekNo.setText("[" + Integer.toString(thisWeekNumber) + "]");
        thisMonthNo.setText("[" + Integer.toString(thisMonthNumber) + "]");
        somedayNo.setText("[" + Integer.toString(somedayNumber) + "]");
        totalTasksNumber = taskObservableList.size() - doneNumber;
        totalTaskNo.setText("[" + Integer.toString(totalTasksNumber) + "]");
        totalDoneNo.setText("[" + Integer.toString(doneNumber) + "]"); 
    }

     /**
     * Determines the time-state of the task in question
     * 
     * =======TIME-STATE TABLE=======
     * |    state   |   due         |
     * |------------|---------------|
     * |    404     |   error       |
     * |    666     |   done        |
     * |    -1      |   overdue     |
     * |    0       |   no due date |
     * |    1       |   today       |
     * |    2       |   this week   |
     * |    3       |   this month  |
     * ==============================
     * 
     * @param task (undone) in question
     * @return Integer based on the time-state
     * 
```
###### /java/seedu/cmdo/ui/TaskCategory.java
``` java
     */
    public Integer getTaskTimeState(ReadOnlyTask task) {
    	assert task != null;
    	
    	if (task.checkDone().value) {
    		return 666;
    	}
    	
        DueByDate dbd = task.getDueByDate();
        
        LocalDate nowDate = LocalDate.now();
        LocalDate weekDate = nowDate.plusWeeks(1);
        LocalDate monthDate = nowDate.plusMonths(1);
        LocalDate dueDate = dbd.start;
        
        // Floating tasks.
        if (dueDate.equals(LocalDate.MIN)) {
            return 0;
        }
        
        if (dueDate.isBefore(nowDate)) return -1;
        if (dueDate.isEqual(nowDate)) return 1;
        if (dueDate.isBefore(weekDate)) return 2;
        if (dueDate.isBefore(monthDate)) return 3;
        
        return 404;
    }
    
```
###### /java/seedu/cmdo/ui/TaskCategory.java
``` java
    public List<Integer> getTaskTimeStateCount(ObservableList<ReadOnlyTask> taskObservableList) {
        assert taskObservableList != null;
    	List<Integer> countMap = new ArrayList<Integer>();
        for (ReadOnlyTask t:taskObservableList) {
        	logger.info("Cycle 1");
            countMap.add(getTaskTimeState(t));        
        }
        return countMap;
    }
    
```
